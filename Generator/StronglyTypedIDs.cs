using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Generator;

public readonly record struct StronglyTypedIDDetails(string Name, string Namespace)
{
    public readonly string Name = Name;
    public readonly string Namespace = Namespace;
};

[Generator(LanguageNames.CSharp)]
public class StronglyTypedIDs : IIncrementalGenerator
{
    public const string AttributeName = "StronglyTypedIDAttribute";
    public const string AttributeCode =
        $$$"""
           namespace SimpleAPI.Core
           {
               [System.AttributeUsage(System.AttributeTargets.Class)]
               public class {{{AttributeName}}} : System.Attribute { }
           }
           """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "SimpleAPI.Generator.Common.g.cs",
            SourceText.From(AttributeCode, Encoding.UTF8)));

        var entityTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"SimpleAPI.Core.{AttributeName}",
                predicate: (node, _) => node is ClassDeclarationSyntax,
                transform: GetStronglyTypedIDDetails
            )
            .Where(static m => m is not null);
        
        context.RegisterSourceOutput(entityTypes, (productionContext, syntax)
            => ExecuteV2(productionContext, syntax));
    }

    private static void ExecuteV2(SourceProductionContext context, in StronglyTypedIDDetails? details)
    {
        if (details is { } dt)
        {
            var stronglyTypedID = PrepareStronglyTypedID(dt.Name, dt.Namespace);
            context.AddSource($"SimpleAPI.{dt.Name}.TypedID.g.cs", stronglyTypedID);
        }
    }

    private static StronglyTypedIDDetails? GetStronglyTypedIDDetails(GeneratorAttributeSyntaxContext context,
        CancellationToken token)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            // nothing to do if this type isn't available
            return null;
        }
        token.ThrowIfCancellationRequested();
        var symbolName = classSymbol.Name;
        var symbolNamespace = classSymbol.ContainingNamespace.ToString();
        return new StronglyTypedIDDetails(symbolName, symbolNamespace);
    }

    private static string PrepareStronglyTypedID(string symbolName, string symbolNamespace)
    {
        // https://andrewlock.net/strongly-typed-id-updates/
        return $$"""
                 //------------------------------------------------------------------------------
                 // <auto-generated>
                 //     This code was generated by source generator
                 //
                 //     Changes to this file may cause incorrect behavior and will be lost if
                 //     the code is regenerated.
                 //
                 //     Created at: {{DateTime.UtcNow.ToLongDateString()}}, {{DateTime.UtcNow.ToLongTimeString()}} 
                 // </auto-generated>
                 //------------------------------------------------------------------------------
                 #nullable enable

                 using SimpleAPI.Core;
                 //using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

                 namespace {{symbolNamespace}};

                 public readonly struct {{symbolName}}ID : IComparable<{{symbolName}}ID>, IEquatable<{{symbolName}}ID>
                 {
                     public int Value { get; }
                     public bool IsNew => Value == 0;
                 
                     public {{symbolName}}ID(int value) => Value = value;
                     
                     public bool Equals({{symbolName}}ID other) => this.Value.Equals(other.Value);
                     public int CompareTo({{symbolName}}ID other) => Value.CompareTo(other.Value);
                 
                     public override bool Equals(object? obj)
                     {
                         if (ReferenceEquals(null, obj)) return false;
                         return obj is {{symbolName}}ID other && Equals(other);
                     }
                 
                     public override int GetHashCode() => Value.GetHashCode();
                     public override string ToString() => Value.ToString();
                 
                     public static bool operator ==({{symbolName}}ID a, {{symbolName}}ID b) => a.CompareTo(b) == 0;
                     public static bool operator !=({{symbolName}}ID a, {{symbolName}}ID b) => !(a == b);
                     
                     public static bool operator <({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) < 0;
                     public static bool operator <=({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) <= 0;
                     public static bool operator >({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) > 0;
                     public static bool operator >=({{symbolName}}ID left, {{symbolName}}ID right) => left.CompareTo(right) >= 0;
                     
                     /*
                     public class EFValueConverter : ValueConverter<{{symbolName}}ID, int>
                     {
                         public EFValueConverter() : base(
                            v => v.Value,
                            v => new {{symbolName}}ID(v)
                        ) { }
                     }
                     */
                 }
                 """;
    }
}
